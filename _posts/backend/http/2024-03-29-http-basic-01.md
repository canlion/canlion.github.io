---
title: "HTTP 웹 기본 지식 정리 - IP, TCP/UDP, DNS"
excerpt: ""

categories:
  - http
tags:
  - [http]

# author_profile: true
# sidebar:
#   nav: "sidebar_category"

toc: true
toc_sticky: true

date: 2024-03-30
last_modified_at: 2024-03-30
---

인프런 / 모든 개발자를 위한 HTTP 웹 기본 지식: [link](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

---

# IP(Internet Protocol, 인터넷 프로토콜)

* 인터넷: 전세계에 걸쳐 연결된 컴퓨터 네트워크

## IP의 역할
인터넷에서 정보를 송수신할때 정보는 여러 노드를 거쳐 목적지에 도달한다.
* 노드: 정보를 송수신하는 컴퓨터/호스트 + 정보 전송을 중개해주는 네트워크 내부 장비들

택배를 보내면 배송을 담당하는 기사님들이 동일한 주소 체계, 배송망 등의 규칙을 지키는 덕에 택배가 무사히 목적지에 도달한다.
마찬가지로 인터넷의 노드들은 정보 전송을 위해 **인터넷 프로토콜**이라는 공통 규약을 준수한다.

![packet-client-to-server](/images/backend/http/http-basic-01/packet-client-to-server.jpg)

IP 프로토콜은 노드마다 IP 주소를 부여하고, IP 주소로 정보의 송수신지를 식별해 데이터를 전달한다(데이터를 전달하는 단위: **패킷**)

![node-throws-packet](/images/backend/http/http-basic-01/node-throws-packet.jpg)

## IP의 한계
IP 프로토콜은 패킷 수신지의 상태를 전혀 고려하지 않고 패킷을 전송하고(비연결성),
송신한 패킷이 소실되거나 여러 패킷이 순서를 지키지 않고 수신지에 도착하는 것을 제어할 수 없고(비신뢰성),
IP 주소의 식별 단위는 노드(=호스트, 시스템, 컴퓨터)이므로 한 노드 안에 여러 어플리케이션이 통신을 수행한다면
어떤 어플리케이션이 정보를 보냈는지, 어떤 어플리케이션이 정보를 받아야하는지 구별할 수 없다.

* **비연결성**: 패킷의 수신지 노드가 정상 운영되고 있는지, 심지어 존재하는지조차 알 수 없더라도 일단 패킷 출발.
* **비신뢰성**: 중간 경로의 노드에 장애가 생겨 패킷이 소실되는 경우, 큰 데이터를 쪼개서 보내기에 패킷의 순서가 중요하지만 수신지에 도착하는 패킷의 순서가 뒤죽박죽인 경우 등 여러 문제 상황에 대처 방안이 없다.
* **어플리케이션의 구분 불가**: IP 주소는 호스트만 식별하므로 호스트 내에서 여러 어플리케이션이 동작하고 있다면 데이터를 어떤 어플리케이션에 보내야할지 알 수 없다.

![where-should-i-go](/images/backend/http/http-basic-01/where-should-i-go.jpg)


# TCP와 UDP

## TCP(Transmission Control Protocol, 전송 제어 프로토콜)

![TCP/IP](/images/backend/http/http-basic-01/tcp-ip.jpg){: .align-center}

IP 프로토콜을 보완하는 프로토콜로 인터넷에서 매우 광범위하게 사용된다. 어플리케이션과 IP 계층 중간에 위치해 소켓이 전달한 메세지를 TCP 정보로 랩핑 후
IP 계층에 전달한다.

### IP 프로토콜 보완

TCP 프로토콜은 IP 프로토콜의 인터넷 비연결성, 비신뢰성, 어플리케이션 구분 불가 문제를 보완한다.

#### 연결지향 - 3 way handshake

![3-way-handshake](/images/backend/http/http-basic-01/3-way-handshake.jpg){: .align-center}

IP 프로토콜의 비연결성 보완을 위한 방안으로 클라이언트가 서버로 요청을 보내고 응답을 받고, 서버가 클라이언트로 요청을 보내고 응답을 받으며
양측이 데이터 수신을 할 수 있음을 확인하고 데이터 통신을 시작한다.

#### 신뢰성 향상 

* 패킷 손실 대비
  * 수신측에서는 패킷을 수신한다면 그 패킷에 대한 수신 확인 응답을 보내야한다. 송신측에서는 수신 확인 응답이 도착하지 않으면 패킷이 손실된 것으로 여기고 패킷을 재전송한다.
* 패킷 순서 정정
  * TCP 정보는 패킷의 그룹과 패킷의 순서를 포함한다. 수신측에서는 같은 그룹에 속한 패킷들의 순서가 뒤죽박죽인 경우 송신측에 순서가 엉망이 된 순서부터 패킷을 다시 보내라고 요청한다.
    * 패킷 [1, 2, 3, 4, 5]가 [1, 2, **4, 3, 5**]순으로 도착한다면 패킷3부터 다시 보내라고 요청한다. 

#### 포트: 호스트 내의 어플리케이션 구분

TCP 정보는 포트, Port를 포함한다. 포트는 어플리케이션(프로세스)을 구분하는 식별자로 IP 정보를 통해 호스트에 패킷이 도착하면 이 포트를 통해 패킷에 담긴 데이터를
어플리케이션, 프로세스에 전달한다. IP 주소는 노드/호스트를 식별하고 **포트는 노드/호스트 내부의 어플리케이션/프로세스를 식별한다.**

* 포트 범위: 0 ~ 65535
  * 0 ~ 1023: well-known port, 널리 사용되는 서비스가 점유하여 유저가 사용하지 않는 포트
    * HTTP: 80
    * HTTPS: 443
    * ...

## UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)

TCP 프로토콜과 같은 레벨에 속하며 마찬가지로 IP 프로토콜을 보완하는 프로토콜.
IP 프로토콜에 어플리케이션 구분을 위한 포트 정보, 데이터 오류 검출을 위한 체크섬 등 약간의 기능을 추가한 프로토콜이다.
IP 프로토콜과 마찬가지로 비연결성, 비신뢰성 프로토콜이다.

### TCP가 있는데 UDP는 왜?

TCP 프로토콜은 다양한 기능을 제공하므로 패킷에 많은 정보가 포함되어 패킷 자체가 크고,
3 way handshake나 데이터 수신에 대한 응답 등 실제 데이터 전송 외에도 여러 메시지 교환이 발생하여 통신이 느리다.
이미 프로토콜 자체가 굉장히 성숙하고 널리 사용되어 변화(최적화)가 쉽지 않다.

이에 반해 UDP 프로토콜은 거의 기능이 없지만 그렇기에 단순하고 빠르며 어플리케이션단에서 커스터마이징하여 필요한 기능을 구현해 사용할 수 있다.
잘 쓰이지 않았다가 다시 사용량이 상승하고 있다.


# DNS(Domain Name System, 도메인 네임 시스템)

IP 주소를 통해 데이터를 송수신할 수 있으나 IP 주소는 xxx.xxx.xxx.xxx 형식으로 여러 호스트의 IP 주소를 외우고 사용하기는 어렵다.
또한 IP 주소가 변경되기라도 하면 관련된 호스트들은 잘못된 주소로 통신을 하게 된다.

DNS는 IP 주소와 **도메인 이름**(사람이 사용하기 쉬운 문자열)을 맵핑해주는 시스템으로 흔히 사용하는 `naver.com`, `google.com` 등이 각 서버 IP 주소에 맵핑된 도메인 이름이다.

![dns](/images/backend/http/http-basic-01/DNS.jpg){: .align-center}

* 호스트는 먼저 DNS 서버와 통신하여 도메인명에 맵핑된 IP 주소를 받아 통신을 시작한다.
  * ex) 구글 DNS 서버: 8.8.8.8, 8.8.4.4
* 도메인명을 사용하는 호스트의 IP 주소가 바뀌는 경우 DNS 서버를 갱신하여 도메인명을 통해 새로운 IP주소를 이용하도록 한다.
